import sys, os, importlib
import rasterio
import skimage

import numpy as np
import pandas as pd
import geopandas as gpd
import osmnx as ox
import GOSTnets as gn
import skimage.graph as graph

from rasterio.mask import mask
from rasterio import features
from rasterio.warp import reproject, Resampling
from shapely.geometry import box, Point
from scipy.ndimage import generic_filter
from pandana.loaders import osm

sys.path.append("../../GOST/")

import GOSTRocks.rasterMisc as rMisc
import GOSTRocks.misc as misc
import GOSTRocks.osmMisc as osm_misc
# Driving Speed
speed_dict = {
   'residential': 20,  # kmph
   'primary': 40,
   'primary_link':35,
   'motorway':50,
   'motorway_link': 45,
   'trunk': 40,
   'trunk_link':35,
   'secondary': 30,
   'secondary_link':25,
   'tertiary':30,
   'tertiary_link': 25,
   'unclassified':20,
   'living_street':10,
   'service':10
}

def get_speed(x, s_dict):
    ''' Get speed from the above speed dict, but some of the suppied x's are actually lists
    INPUT
        x [string] - infra type to look up in s_dict
        s_dict [dictionary] - see speed_dict above
    RETURNS
        [number] speed
    '''
    try: 
        
        speed = s_dict[x]
    except:
        if type(x) == list:
            try:
                speed = s_dict[x[0]]
            except:
                speed = 5
        else:
            speed=5
    return(speed)
    
def get_nodes(b, tags):
    ''' Extract nodes from OSM based on tag query using pandana loaders
        INPUTS
            b [list of numbers] - boundary list from shapely.bounds
            tags [string] - filter to be send to pandana.osm.node_query
        RETURNS
            [geopandas dataframe]     
    '''
    nodes = osm.node_query(b[1], b[0], b[3], b[2], tags=tags)
    nodes_geom = [Point(x) for x in zip(nodes['lon'], nodes['lat'])]
    nodes_df = gpd.GeoDataFrame(nodes[['amenity','lat','lon']], geometry=nodes_geom, crs={'init':'epgs:4326'})
    return(nodes_df)
    
def standardizeInputRasters(inR1, inR2, inR1_outFile, data_type="N"):
    ''' Standardize inR1 to inR2: changes crs, extent, and resolution.

    INPUTS:
        inR1, inR2 [rasterio raster object]
        inR1_outFile [string] - output file for creating inR1 standardized to inR2
        [optional] data_type [character] - Defines the data type of the input raster (inR1).
            It defines the resampling type and works for 'N' for numeric and 'C' for categorical
    RETURNS
        nothing
    '''
    if inR1.crs != inR2.crs:
        raise ValueError("CRS Error")
    #Clip R1 to R2
    #Get JSON of bounding box
    b2 = inR2.bounds
    boxJSON = [{'type': 'Polygon', 'coordinates': [[[b2.left, b2.bottom],[b2.left, b2.top],[b2.right, b2.top],[b2.right, b2.bottom],[b2.left, b2.bottom]]]}]
    out_img, out_transform = mask(inR1, boxJSON, crop=True)
    out_meta = inR1.meta.copy()
    #Re-scale resolution of R1 to R2
    newArr = np.empty(shape=(1, inR2.shape[0], inR2.shape[1]))
    
    if data_type == "N":
        resampling_type = Resampling.cubic
    elif data_type == "C":
        resampling_type = Resampling.nearest
    reproject(out_img, newArr, src_transform=out_transform, dst_transform=inR2.transform, src_crs=inR1.crs, dst_crs=inR2.crs, resampling=resampling_type)
    out_meta.update({"driver": "GTiff",
                     "height": newArr.shape[1],
                     "width": newArr.shape[2],
                     "transform": inR2.transform,
                     "crs": inR2.crs})
    with rasterio.open(inR1_outFile, "w", **out_meta) as dest:
        dest.write(newArr.astype(out_meta['dtype']))

class city_hotspot(object):
    '''
    Calculate hotspots through combining population density, builidng height, and access to amenities
    '''
    def __init__(self, height_raster_file, output_folder):
        ''' Initiate the city_hotspot analysis
            INPUT
                height_raster_file [string] - path to the raster describing builidng height
                output_folder [string] - path to folder to create output
                
            EXAMPLE
                city = hot.city_hotspot(height_raster, out_folder)
                city.extract_other_rasters(global_pop_raster, global_globR)
                rosads = city.extract_osm_data()
                xx = city.generate_walking_raster()
                city.calculate_accessibility()
                city.calculate_pop_hotspots()            
        '''
        self.height_data = rasterio.open(height_raster_file)
        self.bounds = box(*self.height_data.bounds)
        self.intermediate_data = []
        self.output_folder = output_folder
        
        self.wp_file = os.path.join(output_folder, "wp_2020.tif")
        self.wp_file_reproj = os.path.join(output_folder, "wp_2020_re.tif")
        self.lc_file = os.path.join(output_folder, "lcvr_globcover_2015.tif")
        self.lc_file_reproj = os.path.join(output_folder, "lcvr_globcover_2015_re.tif")
        self.toilets_file = os.path.join(output_folder, "toilets.shp")
        self.water_file = os.path.join(output_folder, "water_points.shp")
        self.shops_file = os.path.join(output_folder, "shops.shp")
        self.roads_file = os.path.join(output_folder, "road_network.shp")
        self.walking_time = os.path.join(output_folder, "traversal_time.tif")
        self.walking_speed = os.path.join(output_folder, "traversal_speed.tif")
        self.pop_by_floor = os.path.join(output_folder, "pop_floor.tif")

    def extract_other_rasters(self, pop_raster, land_cover_raster):
        ''' Extract population, landcover data that match the existing height data
            INPUT
                pop_raster [rasterio] - global population raster from which the city data are extracted
                land_cover_raster [rasterio] - global landcover dataset
            RETURNS
                NA - writes all results to file
        '''
        if not os.path.exists(self.wp_file):
            wp_data, out_transform = mask(pop_raster, shapes=[self.bounds], crop=True)
            wp_data[wp_data < 0] = 0
            meta = self.height_data.meta.copy()
            meta.update(width=wp_data.shape[2], 
                        height=wp_data.shape[1],
                        transform=out_transform,
                        dtype = wp_data.dtype)
            
            with rasterio.open(self.wp_file, 'w', **meta) as out:
                out.write(wp_data)
        if not os.path.exists(self.wp_file_reproj):
            # standardize the wp_smoothed dataset to the highight dataset    
            standardizeInputRasters(rasterio.open(self.wp_file), self.height_data, self.wp_file_reproj, data_type='N')
        
        if not os.path.exists(self.lc_file):
            wp_data, out_transform = mask(land_cover_raster, shapes=[self.bounds], crop=True)
            meta = self.height_data.meta.copy()
            meta.update(width=wp_data.shape[2], 
                        height=wp_data.shape[1],
                        transform=out_transform,
                        dtype = wp_data.dtype)
            
            with rasterio.open(self.lc_file, 'w', **meta) as out:
                out.write(wp_data)
        if not os.path.exists(self.lc_file_reproj):
            # standardize the wp_smoothed dataset to the highight dataset    
            standardizeInputRasters(rasterio.open(self.lc_file), self.height_data, self.lc_file_reproj, data_type='C')
            
    def extract_osm_data(self):
        ''' Extract amenities and the road network from OSM
        '''
        if not os.path.exists(self.toilets_file):
            amenities = ['toilets', 'washroom', 'restroom']
            toilets_tags = '"amenity"~"{}"'.format('|'.join(amenities))
            try:
                self.toilets = get_nodes(self.height_data.bounds, toilets_tags)
                self.toilets.to_file(self.toilets_file)  
            except:
                pass
        
        if not os.path.exists(self.water_file):
            amenities = ['water_points', 'drinking_water', 'pumps', 'water_pumps', 'well']
            water_tags = '"amenity"~"{}"'.format('|'.join(amenities))
            try:
                self.water_points = get_nodes(self.height_data.bounds, water_tags)
                self.water_points.to_file(self.water_file)
            except:
                pass

        if not os.path.exists(self.shops_file):
            amenities = ['supermarket', 'convenience', 'general', 'department_stores', 'wholesale', 'grocery', 'general']
            shp_tags = '"shop"~"{}"'.format('|'.join(amenities))
            try:
                self.shops = get_nodes(self.height_data.bounds, shp_tags)
                self.shops.to_file(self.shops_file)       
            except:
                pass
        
        if not os.path.exists(self.roads_file):
            b = self.height_data.bounds
            sel_graph = ox.graph_from_bbox(b[3], b[1], b[2], b[0], retain_all=True)
            self.sel_roads = gn.edge_gdf_from_graph(sel_graph)
            self.sel_roads['speed'] = self.sel_roads['highway'].apply(lambda x: get_speed(x, speed_dict))
            bad_fields = ['name','width','maxspeed','ref','tunnel','service','area','lanes','junction','oneway','bridge','access']
            for f in bad_fields:
                try:
                    self.sel_roads.drop([f], axis=1, inplace=True)
                except:
                    pass
            def get_type(x):
                if type(x) == list:
                    return(x[0])
                else:
                    return(x)
            self.sel_roads['highway'] = self.sel_roads['highway'].apply(get_type)
            self.sel_roads['osmid'] = self.sel_roads['osmid'].apply(get_type)
            try:
                self.sel_roads.to_file(self.roads_file)
            except:
                print("Error writing roads to disk")
                return(self.sel_roads)
        else:
            self.sel_roads = gpd.read_file(self.roads_file)
            
    def generate_walking_raster(self, resolution=90):
        ''' Generate a map of walking speed combining landcover and road network
        '''
        if not os.path.exists(self.walking_time):
            # load the landcover data, classify into water (0.5), other (2), and urban (3)
            lc_raster = rasterio.open(self.lc_file_reproj)
            lc_data = lc_raster.read()
            walking_speed = lc_data.copy()
            walking_speed[lc_data < 190] = 2
            walking_speed[lc_data == 190] = 3
            walking_speed[lc_data > 190] = 1
            
            #Open the road network and burn all in at uniform (5)
            shapes = ((row['geometry'], 5) for idx, row in self.sel_roads.iterrows())
            speed_image = features.rasterize(shapes, out_shape=self.height_data.shape, transform=self.height_data.transform, fill=0)
            # stack rasterized roads and lc_speed and take maximum
            stacked = np.dstack([walking_speed[0,:,:], speed_image])
            max_speed = np.amax(stacked, axis=2)
            # Convert road network from travel speed to traversal time (seconds to cross)
            traversal_speed = resolution / (max_speed * 1000.0 / (60.0 * 60.0))
            meta = lc_raster.meta.copy()
            meta.update(dtype = traversal_speed.dtype)
            with rasterio.open(self.walking_time, 'w', **meta) as out:
                out.write_band(1, traversal_speed)        
            return(traversal_speed)
            meta = lc_raster.meta.copy()
            meta.update(dtype = max_speed.dtype)
            with rasterio.open(self.walking_speed, 'w', **meta) as out:
                out.write_band(1, max_speed)
            
    def calculate_accessibility(self):
        ''' Using skimage.MCP to calculate walking access through integration of landcover dataset and 
            the OSM road network
        '''
        traversal_raster = rasterio.open(self.walking_time)
        time_data = traversal_raster.read()[0,:,:]
        
        # create skimage graph
        inH = self.height_data
        meta = inH.meta.copy()
        mcp = skimage.graph.MCP_Geometric(time_data)
        # iterate through amenity
        for amenity_file in [self.toilets_file, self.water_file, self.shops_file]:
            if os.path.exists(amenity_file):
                amenity = gpd.read_file(amenity_file)
                amenity_name = os.path.basename(amenity_file).replace(".shp", "")
                distance_raster = os.path.join(self.output_folder, '%s_distance_roads.tif' % amenity_name)
                if not os.path.exists(distance_raster):
                    costs, traceback = mcp.find_costs(list(set([inH.index(x.x, x.y) for x in amenity['geometry']])))            
                    meta.update(dtype=costs.dtype)
                    with rasterio.open(distance_raster, 'w', **meta) as out:
                        out.write_band(1, costs)
                
    def calculate_pop_hotspots(self, resolution=90):
        ''' Calculate population density hotspots based on TFA
        '''
        # Divide population by hieght to get a density per footage analysis
        pop_raster = rasterio.open(self.wp_file_reproj)
        pop_data = pop_raster.read()
        height_data = (self.height_data.read() / 3) * (resolution * resolution) # total floor area

        pop_by_floor = pop_data/height_data
        # sum filter
        def sum(P):    
            return(P.sum())
        # smooth WP dataset such that each cell is the sum of a 3x3 filter
        pop_by_floor[0,:,:] = generic_filter(pop_by_floor[0,:,:], sum, (3,3))
        
        meta = self.height_data.meta.copy()
        meta.update(dtype = pop_by_floor.dtype)
        
        with rasterio.open(self.pop_by_floor, 'w', **meta) as out:
            out.write_band(1, pop_by_floor[0,:,:])
            
    def calculate_accessibility_hotspots(self):
        '''
        '''
        fubar="TBD"
        
        
            
                
        
        