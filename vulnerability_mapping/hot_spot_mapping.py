import sys, os, importlib, math, shutil
import rasterio
import skimage

import numpy as np
import pandas as pd
import geopandas as gpd
import osmnx as ox
import GOSTnets as gn
import skimage.graph as graph

from rasterio.mask import mask
from rasterio import features
from rasterio.warp import reproject, Resampling
from shapely.geometry import box, Point
from scipy.ndimage import generic_filter
from pandana.loaders import osm

sys.path.append("../../GOST/")

import GOSTRocks.rasterMisc as rMisc
import GOSTRocks.misc as misc
import GOSTRocks.osmMisc as osm_misc
# Driving Speed for attributing road networks with speed
speed_dict = {
   'residential': 20,  # kmph
   'primary': 40,
   'primary_link':35,
   'motorway':50,
   'motorway_link': 45,
   'trunk': 40,
   'trunk_link':35,
   'secondary': 30,
   'secondary_link':25,
   'tertiary':30,
   'tertiary_link': 25,
   'unclassified':20,
   'living_street':10,
   'service':10
}

def get_speed(x, s_dict):
    ''' Get speed from the above speed dict, but some of the suppied x's are actually lists
    INPUT
        x [string] - infra type to look up in s_dict
        s_dict [dictionary] - see speed_dict above
    RETURNS
        [number] speed
    '''
    try: 
        
        speed = s_dict[x]
    except:
        if type(x) == list:
            try:
                speed = s_dict[x[0]]
            except:
                speed = 5
        else:
            speed=5
    return(speed)
    
def get_nodes(b, tags):
    ''' Extract nodes from OSM based on tag query using pandana loaders
        INPUTS
            b [list of numbers] - boundary list from shapely.bounds
            tags [string] - filter to be send to pandana.osm.node_query
        RETURNS
            [geopandas dataframe]     
    '''
    nodes = osm.node_query(b[1], b[0], b[3], b[2], tags=tags)
    nodes_geom = [Point(x) for x in zip(nodes['lon'], nodes['lat'])]
    nodes_df = gpd.GeoDataFrame(nodes[['amenity','lat','lon']], geometry=nodes_geom, crs={'init':'epgs:4326'})
    return(nodes_df)
    
def standardizeInputRasters(inR1, inR2, inR1_outFile, data_type="N"):
    ''' Standardize inR1 to inR2: changes crs, extent, and resolution.

    INPUTS:
        inR1, inR2 [rasterio raster object]
        inR1_outFile [string] - output file for creating inR1 standardized to inR2
        [optional] data_type [character] - Defines the data type of the input raster (inR1).
            It defines the resampling type and works for 'N' for numeric and 'C' for categorical
    RETURNS
        nothing
    '''
    if inR1.crs != inR2.crs:
        raise ValueError("CRS Error")
    #Clip R1 to R2
    #Get JSON of bounding box
    b2 = inR2.bounds
    boxJSON = [{'type': 'Polygon', 'coordinates': [[[b2.left, b2.bottom],[b2.left, b2.top],[b2.right, b2.top],[b2.right, b2.bottom],[b2.left, b2.bottom]]]}]
    out_img, out_transform = mask(inR1, boxJSON, crop=True)
    out_meta = inR1.meta.copy()
    #Re-scale resolution of R1 to R2
    newArr = np.empty(shape=(1, inR2.shape[0], inR2.shape[1]))
    
    if data_type == "N":
        resampling_type = Resampling.cubic
    elif data_type == "C":
        resampling_type = Resampling.nearest
    reproject(out_img, newArr, src_transform=out_transform, dst_transform=inR2.transform, src_crs=inR1.crs, dst_crs=inR2.crs, resampling=resampling_type)
    out_meta.update({"driver": "GTiff",
                     "height": newArr.shape[1],
                     "width": newArr.shape[2],
                     "transform": inR2.transform,
                     "crs": inR2.crs})
    with rasterio.open(inR1_outFile, "w", **out_meta) as dest:
        dest.write(newArr.astype(out_meta['dtype']))

class city_hotspot(object):
    '''
    Calculate hotspots through combining population density, builidng height, and access to amenities
    '''
    def __init__(self, height_raster_file, output_folder):
        ''' Initiate the city_hotspot analysis
            INPUT
                height_raster_file [string] - path to the raster describing builidng height
                output_folder [string] - path to folder to create output
                
            EXAMPLE
                city = hot.city_hotspot(height_raster, out_folder)
                city.extract_other_rasters(global_pop_raster, global_globR)
                rosads = city.extract_osm_data()
                xx = city.generate_walking_raster()
                city.calculate_accessibility()
                city.calculate_pop_hotspots()            
        '''
        self.height_data = rasterio.open(height_raster_file)
        self.bounds = box(*self.height_data.bounds)
        self.intermediate_data = []
        self.output_folder = output_folder
        
        self.wp_file = os.path.join(output_folder, "wp_2020.tif")
        self.wp_file_reproj = os.path.join(output_folder, "wp_2020_re.tif")
        self.lc_file = os.path.join(output_folder, "lcvr_globcover_2015.tif")
        self.lc_file_reproj = os.path.join(output_folder, "lcvr_globcover_2015_re.tif")
        self.toilets_file = os.path.join(output_folder, "toilets.shp")
        self.water_file = os.path.join(output_folder, "water_points.shp")
        self.shops_file = os.path.join(output_folder, "shops.shp")
        self.roads_file = os.path.join(output_folder, "road_network.shp")
        self.walking_speed = os.path.join(output_folder, "traversal_speed.tif")
        self.walking_time = os.path.join(output_folder, "traversal_time.tif")
        
        self.pop_by_floor = os.path.join(output_folder, "pop_floor.tif")

        
    def combine_results(self, base_map, hotspot_files, thresh=0.29):
        ''' copy the vizualization qgis document to the output folder, summarize population in hotspots
        
        '''
        out_map = os.path.join(self.output_folder, os.path.basename(base_map))
        if out_map != base_map:
            shutil.copy(base_map, out_map)
            
        # Open the hotspot datasets, apply threshold and summarize population
        popD = rasterio.open(self.wp_file_reproj).read()
        popD[popD < 0] = 0
        pop_h = rasterio.open(self.pop_by_floor).read()        
        pop_h = (pop_h > thresh).astype(int)
        pop_h_sum = (pop_h * popD).sum()
        final = pop_h
        total_pop = popD.sum()
        
        hot_spot_summary = {}
        hot_spot_summary['total_pop'] = total_pop
        hot_spot_summary['pop_hotspot'] = pop_h_sum
        for h_file in hotspot_files:
            if os.path.exists(h_file):
                inR = rasterio.open(h_file).read()
                inR = (inR > thresh).astype(int)
                pop_h = (inR * popD).sum()
                #combine all hotspots data
                try:
                    final = final + inR
                except:
                    final = inR
            else:
                pop_h = -1
            hot_spot_summary[os.path.basename(h_file).replace(".tif", "")] = pop_h
        
        # get combo hotspot population
        final = (final > 0).astype(int)
        final_h = (final * popD).sum()
        hot_spot_summary['combo_hotspot'] = final_h
        return(hot_spot_summary)
    
    def extract_other_rasters(self, pop_raster, land_cover_raster):
        ''' Extract population, landcover data that match the existing height data
            INPUT
                pop_raster [rasterio] - global population raster from which the city data are extracted
                land_cover_raster [rasterio] - global landcover dataset
            RETURNS
                NA - writes all results to file
                
            ##TODO: Look at re-smapling to see how numbers change
        '''
        if not os.path.exists(self.wp_file):
            wp_data, out_transform = mask(pop_raster, shapes=[self.bounds], crop=True)
            wp_data[wp_data < 0] = 0
            meta = self.height_data.meta.copy()
            meta.update(width=wp_data.shape[2], 
                        height=wp_data.shape[1],
                        transform=out_transform,
                        dtype = wp_data.dtype)
            
            with rasterio.open(self.wp_file, 'w', **meta) as out:
                out.write(wp_data)
        if not os.path.exists(self.wp_file_reproj):
            # standardize the wp_smoothed dataset to the highight dataset    
            standardizeInputRasters(rasterio.open(self.wp_file), self.height_data, self.wp_file_reproj, data_type='N')
        
        if not os.path.exists(self.lc_file):
            wp_data, out_transform = mask(land_cover_raster, shapes=[self.bounds], crop=True)
            meta = self.height_data.meta.copy()
            meta.update(width=wp_data.shape[2], 
                        height=wp_data.shape[1],
                        transform=out_transform,
                        dtype = wp_data.dtype)
            
            with rasterio.open(self.lc_file, 'w', **meta) as out:
                out.write(wp_data)
        if not os.path.exists(self.lc_file_reproj):
            # standardize the wp_smoothed dataset to the highight dataset    
            standardizeInputRasters(rasterio.open(self.lc_file), self.height_data, self.lc_file_reproj, data_type='C')
            
    def extract_osm_data(self):
        ''' Extract amenities and the road network from OSM
        '''
        if not os.path.exists(self.toilets_file):
            amenities = ['toilets', 'washroom', 'restroom']
            toilets_tags = '"amenity"~"{}"'.format('|'.join(amenities))
            try:
                self.toilets = get_nodes(self.height_data.bounds, toilets_tags)
                self.toilets.to_file(self.toilets_file)  
            except:
                pass
        
        if not os.path.exists(self.water_file):
            amenities = ['water_points', 'drinking_water', 'pumps', 'water_pumps', 'well']
            water_tags = '"amenity"~"{}"'.format('|'.join(amenities))
            try:
                self.water_points = get_nodes(self.height_data.bounds, water_tags)
                self.water_points.to_file(self.water_file)
            except:
                pass

        if not os.path.exists(self.shops_file):
            amenities = ['supermarket', 'convenience', 'general', 'department_stores', 'wholesale', 'grocery', 'general']
            shp_tags = '"shop"~"{}"'.format('|'.join(amenities))
            try:
                self.shops = get_nodes(self.height_data.bounds, shp_tags)
                self.shops.to_file(self.shops_file)       
            except:
                pass
        
        if not os.path.exists(self.roads_file):
            b = self.height_data.bounds
            sel_graph = ox.graph_from_bbox(b[3], b[1], b[2], b[0], retain_all=True)
            self.sel_roads = gn.edge_gdf_from_graph(sel_graph)
            self.sel_roads['speed'] = self.sel_roads['highway'].apply(lambda x: get_speed(x, speed_dict))
            bad_fields = ['name','width','maxspeed','ref','tunnel','service','area','lanes','junction','oneway','bridge','access']
            for f in bad_fields:
                try:
                    self.sel_roads.drop([f], axis=1, inplace=True)
                except:
                    pass
            def get_type(x):
                if type(x) == list:
                    return(x[0])
                else:
                    return(x)
            self.sel_roads['highway'] = self.sel_roads['highway'].apply(get_type)
            self.sel_roads['osmid'] = self.sel_roads['osmid'].apply(get_type)
            try:
                self.sel_roads.to_file(self.roads_file)
            except:
                print("Error writing roads to disk")
                return(self.sel_roads)
        else:
            self.sel_roads = gpd.read_file(self.roads_file)
            
    def generate_walking_raster(self, resolution=90):
        ''' Generate a map of walking speed combining landcover and road network
        '''
        if not os.path.exists(self.walking_time):
            # load the landcover data, classify into water (0.5), other (2), and urban (3)
            lc_raster = rasterio.open(self.lc_file_reproj)
            lc_data = lc_raster.read()
            walking_speed = lc_data.copy()
            walking_speed[lc_data < 190] = 2
            walking_speed[lc_data == 190] = 3
            walking_speed[lc_data > 190] = 1
            
            #Open the road network and burn all in at uniform (5)
            shapes = ((row['geometry'], 5) for idx, row in self.sel_roads.iterrows())
            speed_image = features.rasterize(shapes, out_shape=self.height_data.shape, transform=self.height_data.transform, fill=0)
            # stack rasterized roads and lc_speed and take maximum
            stacked = np.dstack([walking_speed[0,:,:], speed_image])
            max_speed = np.amax(stacked, axis=2)
            # Convert road network from travel speed to traversal time (seconds to cross)
            traversal_speed = resolution / (max_speed * 1000.0 / (60.0 * 60.0))
            meta = lc_raster.meta.copy()
            meta.update(dtype = traversal_speed.dtype)
            with rasterio.open(self.walking_time, 'w', **meta) as out:
                out.write_band(1, traversal_speed)        
            return(traversal_speed)
            meta = lc_raster.meta.copy()
            meta.update(dtype = max_speed.dtype)
            with rasterio.open(self.walking_speed, 'w', **meta) as out:
                out.write_band(1, max_speed)
            
    def calculate_accessibility(self):
        ''' Using skimage.MCP to calculate walking access through integration of landcover dataset and 
            the OSM road network
        '''
        distance_raster = os.path.join(self.output_folder, '%s_distance_roads.tif' % amenity_name)
        if not os.path.exists(distance_raster):
            traversal_raster = rasterio.open(self.walking_time)
            time_data = traversal_raster.read()[0,:,:]
            
            # create skimage graph
            inH = self.height_data
            meta = inH.meta.copy()
            mcp = skimage.graph.MCP_Geometric(time_data)
            # iterate through amenity
            for amenity_file in [self.toilets_file, self.water_file, self.shops_file]:
                if os.path.exists(amenity_file):
                    amenity = gpd.read_file(amenity_file)
                    amenity_name = os.path.basename(amenity_file).replace(".shp", "")
                    if not os.path.exists(distance_raster):
                        costs, traceback = mcp.find_costs(list(set([inH.index(x.x, x.y) for x in amenity['geometry']])))            
                        meta.update(dtype=costs.dtype)
                        with rasterio.open(distance_raster, 'w', **meta) as out:
                            out.write_band(1, costs)
                
    def calculate_pop_hotspots(self, resolution=90, pop_layer = '', out_file=''):
        ''' Calculate population density hotspots based on TFA
        '''
        # Divide population by hieght to get a density per footage analysis
        if pop_layer == '':
            pop_layer = self.wp_file_reproj
            
        if out_file == '':
            out_file = self.pop_by_floor
            
        if not os.path.exists(out_file):    
            pop_raster = rasterio.open(pop_layer)
            pop_data = pop_raster.read()
            height_data = (self.height_data.read() / 3) * (resolution * resolution) # total floor area

            pop_by_floor = pop_data/height_data
            pop_by_floor[pop_by_floor < 0] = 0
            pop_by_floor[pop_by_floor > 10000] = 0

            # sum filter
            def sum(P):    
                return(P.sum())
            # smooth WP dataset such that each cell is the sum of a 3x3 filter
            pop_by_floor[0,:,:] = generic_filter(pop_by_floor[0,:,:], sum, (3,3))

           
            meta = self.height_data.meta.copy()
            meta.update(dtype = pop_by_floor.dtype)
            
            with rasterio.open(out_file, 'w', **meta) as out:
                out.write_band(1, pop_by_floor[0,:,:])

    def calculate_accessibility_hotspots(self, time_raster, out_hotspots, window=25):
        pop_raster = self.wp_file_reproj
        pop_floor_raster = self.pop_by_floor

        #Read in the time raster and create and inverse travel raster
        timeR = rasterio.open(time_raster)
        timeD = timeR.read()
        invD = 1/((timeD/60)**2) # convert seconds to minutes and square
        invD[timeD == 0.0] = 0 # set inverse values at service points to 0

        # Mulitple the inverse travel raster by the TFA raster
        popR = rasterio.open(pop_floor_raster)
        popD = popR.read()
        popD[np.isnan(popD)] = 0
        pop_inv = invD * popD
        out = pop_inv * 0

        #Run a filter over the dataset to sum the TFA within the window
        yy = generic_filter(pop_inv[0,:,:], sum, (window, window))
        yy = yy.astype(popR.meta['dtype'])
        #Multiply that windowed sum by the inverse travel value
        yy = (yy * invD) * 1/8
        # Set the risk value at service locations to the maximum of the dataset
        yy[timeD == 0.0] = yy.max()
        yy = yy.astype(popR.meta['dtype'])
        
        with rasterio.open(out_hotspots, 'w', **popR.meta) as outR:
            outR.write(yy)
                
    def calculate_accessibility_hotspots_dist_decay(self, time_raster, pop_raster, 
            max_time = 1200, dist_decay=0.005, window = 25):
        ''' Calculate accessibility risk based on proximity to amenities
        '''
        cur_folder = self.output_folder
        decay_raster = os.path.join(cur_folder, "wp_2020_decay_pop.tif")
        decay_raster_window = os.path.join(cur_folder, "wp_2020_decay_pop_window.tif")
        decay_vals = os.path.join(cur_folder, "decayRast.tif")

        distance_raster = rasterio.open(time_raster)
        distR = distance_raster.read()

        pop_raster = rasterio.open(pop_raster)
        popR = pop_raster.read()

        #exclude population that is too far away (beyond max_time)
        popR = popR * ((distR < max_time) * 1)

        #Create inverse time raster
        decayFunction = lambda x: np.exp(-1 * dist_decay * x)
        decayDist = decayFunction(distR)
        # multiply distance decay raster by Population
        decayPop = popR * decayDist
        decayPop = decayPop.astype(pop_raster.meta['dtype'])
        
        #For the locations where the shops are located, set the pop to 0
        decayPop[decayPop == popR] = 0

        # apply summary function across decay pop raster summarizing 
        #   pop within a roving window, only summing population that is further away
        def sum(P):
            return(P.sum())
        decayPop_window = decayPop * 0
        decayPop_window[0,:,:] = generic_filter(decayPop[0,:,:], sum, (window,window))
        meta = pop_raster.meta.copy()
        meta.update(dtype = decayDist.dtype)

        decayPop_window = decayPop_window.astype(meta['dtype'])
        with rasterio.open(decay_vals, 'w', **meta) as out:
            out.write(decayDist)

        with rasterio.open(decay_raster, 'w', **pop_raster.meta) as out:
            out.write(decayPop)

        with rasterio.open(decay_raster_window, 'w', **meta) as out:
            out.write(decayPop_window)
            
        return(decay_raster_window)
    
    def calculate_accessibility_hotspots_advanced(self, time_raster, pop_raster, 
            dist_decay=0.005, window = 25, interim = False):
        ''' Calculate accessibility risk based on proximity to amenities
        '''
        cur_folder = self.output_folder
        decay_raster = os.path.join(cur_folder, "wp_2020_decay_pop_adv.tif")
        decay_raster_window = os.path.join(cur_folder, "wp_2020_decay_pop_window_adv.tif")
        decay_vals = os.path.join(cur_folder, "decayRast_adv.tif")

        distance_raster = rasterio.open(time_raster)
        distR = distance_raster.read()

        pop_raster = rasterio.open(pop_raster)
        popR = pop_raster.read()

        #Create inverse time raster
        decayFunction = lambda x: np.exp(-1 * dist_decay * x)
        decayDist = decayFunction(distR)
        # multiply distance decay raster by Population
        decayPop = popR * decayDist
        decayPop = decayPop.astype(pop_raster.meta['dtype'])
        
        #For the locations where the shops are located, set the pop to 0
        #decayPop[decayPop == popR] = 0

        # apply summary function across decay pop raster summarizing 
        #   pop within a roving window, only summing population that is further away
        xx = np.dstack([decayPop[0,:,:], distR[0,:,:]])
        def sum_less_than_center(P):   
            P = P.reshape((window,window,2))
            pop = P[:,:,0]
            dist = P[:,:,1]
            center = math.floor(pop.shape[0]/2)
            min_dist = dist[center,center]
            pop = (dist > min_dist).astype(int) * pop
            return(pop.sum())

        out = xx * 0
        yy = generic_filter(xx, sum_less_than_center, (window,window,2), output=out)
        decayPop_window = yy[:,:,0]
        
        meta = pop_raster.meta.copy()
        meta.update(dtype = decayDist.dtype)
        if interim:
            with rasterio.open(decay_vals, 'w', **meta) as out:
                out.write(decayDist)

            with rasterio.open(decay_raster, 'w', **pop_raster.meta) as out:
                out.write(decayPop)

        with rasterio.open(decay_raster_window, 'w', **meta) as out:
            out.write_band(1, decayPop_window)            
        return(decay_raster_window)
        
        
        def calculate_accessibility_hotspots_orig(self, time_raster, pop_raster, pop_floor_raster,
                window = 25, interim = False):
            ''' Calculate accessibility risk based on proximity to amenities
            '''
            tfa = rasterio.open(pop_floor_raster)
            timeR = rasterio.open(time_raster)
            
            cur_folder = self.output_folder
            decay_raster = os.path.join(cur_folder, "wp_2020_decay_pop_orig.tif")
            decay_raster_window = os.path.join(cur_folder, "wp_2020_decay_pop_window_orig.tif")
            decay_vals = os.path.join(cur_folder, "decayRast_orig.tif")

            distance_raster = rasterio.open(time_raster)
            distR = distance_raster.read()

            pop_raster = rasterio.open(pop_raster)
            popR = pop_raster.read()

            decayDist = 1/distR
            # multiply distance decay raster by Population
            decayPop = popR * decayDist
            decayPop = decayPop.astype(pop_raster.meta['dtype'])
            
            #For the locations where the shops are located, set the pop to 0
            #decayPop[decayPop == popR] = 0

            # apply summary function across decay pop raster summarizing 
            #   pop within a roving window, only summing population that is further away
            xx = np.dstack([decayPop[0,:,:], distR[0,:,:]])
            def sum_less_than_center(P):   
                P = P.reshape((window,window,2))
                pop = P[:,:,0]
                dist = P[:,:,1]
                center = math.floor(pop.shape[0]/2)
                min_dist = dist[center,center]
                pop = (dist > min_dist).astype(int) * pop
                return(pop.sum())

            out = xx * 0
            yy = generic_filter(xx, sum_less_than_center, (window,window,2), output=out)
            decayPop_window = yy[:,:,0]
            
            meta = pop_raster.meta.copy()
            meta.update(dtype = decayDist.dtype)
            if interim:
                with rasterio.open(decay_vals, 'w', **meta) as out:
                    out.write(decayDist)

                with rasterio.open(decay_raster, 'w', **pop_raster.meta) as out:
                    out.write(decayPop)

            with rasterio.open(decay_raster_window, 'w', **meta) as out:
                out.write_band(1, decayPop_window)            
            return(decay_raster_window)
            

        
        
        
        
            
                
        
        